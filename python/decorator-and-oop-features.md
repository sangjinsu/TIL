# 데코레이터 패턴과 OOP 특성

## 데코레이터 패턴

```python
def choco(func):
    def new_func():
        print('choco ', end='')
        func()

    return new_func


@choco
def bread():
    print('bread')


@choco
def cookie():
    print('cookie')


@choco
def milk():
    print('milk')


bread()
cookie()
milk()
'''
choco bread
choco cookie
choco milk
'''
```

## OOP 특성

- 캡슐화 encapsulation
  - 데이터와 그 데이터에 작용하는 메서드를 하나 묶음
  - 정보 숨기기(data hiding): 개체 안에 있는 데이터를 외부(다른 클래스에 속한 개체들)로부터 보호


- 상속 inheritance
  - 현존하는 개체를 기반으로 확장된 개체를 만드는 방법
  - 확장된 개체 - 기존 개체의 속한 데이터와 동작을 물려 받고 여기에 더 추가할 수 있음
  - 코드 중복을 막아 실용적임


-  다형성
  - 같은 지시를 내렸을 때 다른 종류의 개체가 동작을 다르게 하는 것
  - 어떤 함수 구현이 실행될지는 실행 중에 결정되고 이를 늦은 바인딩(late binding)이라고 한다
  - 다형성 활용을 위해서는 상속 관계가 필요하다
  - 다른 종류의 개체를 편하게 저장 및 처리 하기 위해 슈퍼 클래스 배열을 사용한다


- 데이터 추상화
  - 개체 속에 있는 실제 데이터나 함수 구현 함법에 종속되지 않는다
  - 일반화, 모델링
  - 개체 사용시 그 안에 정확히 어떤 데이터가 있는지 알 필요가 없음
  - 개체 안에 있는 데이터에 직접 접근 불가하지만 함수를 통해 접근한다
  - 캡슐화는 데이터 추상화를 하는 방법 중 하나
  - 다형성을 통한 추상화 - 추상 클래스나 인터페이스를 사용하는 추상화

- 연관 association
  - 어떤 개체가 제공하는 기능을 다른 개체가 이용하는 관계
  - 한 개체가 다른 개체를 참조하는 관계
  - 세부적으로 집합과 컴포지션으로 나누기도 한다

- 컴포지션 composition
  - 여러 개체를 조립해서 새로운 개체를 만드는 방법
  - 집합과의 차이점 - 부품으로는 의미가 없으며 조립 개체가 사라지면 부품 개체도 필요 없어진다.

- 집합
  - 여러 개체를 모아 새로운 개체를 만들지만 별도의 개체들로 존재 가능

